import { Injectable } from '@nestjs/common';
import * as ExcelJS from 'exceljs';
import { ExportConfig } from '../interfaces/report.interface';

@Injectable()
export class ExcelService {
  /**
   * Generate Excel file from data
   */
  async generateExcel(config: ExportConfig): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Report');

    // Set worksheet properties
    worksheet.properties.defaultRowHeight = 20;

    // Add title
    worksheet.mergeCells('A1', this.getColumnLetter(config.columns.length) + '1');
    const titleCell = worksheet.getCell('A1');
    titleCell.value = config.title;
    titleCell.font = { size: 16, bold: true };
    titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
    titleCell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' },
    };
    titleCell.font = { ...titleCell.font, color: { argb: 'FFFFFFFF' } };

    // Add metadata row
    if (config.metadata) {
      worksheet.addRow([]);
      const metadataRow = worksheet.addRow([
        `Generated: ${config.metadata.generatedAt?.toLocaleString() || new Date().toLocaleString()}`,
        `Generated By: ${config.metadata.generatedBy || 'System'}`,
      ]);
      metadataRow.font = { italic: true, size: 10 };
    }

    // Add empty row
    worksheet.addRow([]);

    // Add headers
    const headerRow = worksheet.addRow(config.columns.map((col) => col.header));
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF5B9BD5' },
    };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.height = 25;

    // Set column widths
    config.columns.forEach((col, index) => {
      const column = worksheet.getColumn(index + 1);
      column.width = col.width || 15;
    });

    // Add data rows
    config.data.forEach((row) => {
      const rowData = config.columns.map((col) => {
        const value = this.getNestedValue(row, col.field);
        return this.formatValue(value, col.type, col.format);
      });
      const dataRow = worksheet.addRow(rowData);

      // Apply cell formatting based on type
      config.columns.forEach((col, index) => {
        const cell = dataRow.getCell(index + 1);
        if (col.type === 'number') {
          cell.alignment = { horizontal: 'right' };
        } else if (col.type === 'date') {
          cell.alignment = { horizontal: 'center' };
        }
      });
    });

    // Add borders to all cells
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber > 3) {
        // Skip title and metadata rows
        row.eachCell((cell) => {
          cell.border = {
            top: { style: 'thin' },
            left: { style: 'thin' },
            bottom: { style: 'thin' },
            right: { style: 'thin' },
          };
        });
      }
    });

    // Auto-filter
    const lastColumn = this.getColumnLetter(config.columns.length);
    worksheet.autoFilter = {
      from: { row: 4, column: 1 },
      to: { row: 4 + config.data.length, column: config.columns.length },
    };

    // Freeze header row
    worksheet.views = [{ state: 'frozen', ySplit: 4 }];

    // Generate buffer - ExcelJS returns ArrayBuffer, convert to Buffer
    const arrayBuffer = await workbook.xlsx.writeBuffer();
    const buffer = Buffer.from(arrayBuffer);

    console.log(`[ExcelService] Generated Excel buffer: ${buffer.length} bytes`);

    return buffer;
  }

  /**
   * Get column letter from index (A, B, C, ..., Z, AA, AB, ...)
   */
  private getColumnLetter(columnNumber: number): string {
    let letter = '';
    while (columnNumber > 0) {
      const temp = (columnNumber - 1) % 26;
      letter = String.fromCharCode(temp + 65) + letter;
      columnNumber = Math.floor((columnNumber - temp - 1) / 26);
    }
    return letter;
  }

  /**
   * Get nested value from object using dot notation
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, prop) => current?.[prop], obj);
  }

  /**
   * Format value based on type and format
   */
  private formatValue(value: any, type: string, format?: string): any {
    if (value === null || value === undefined) {
      return '';
    }

    switch (type) {
      case 'date':
        return value instanceof Date ? value : new Date(value);
      case 'number':
        return typeof value === 'number' ? value : parseFloat(value) || 0;
      case 'boolean':
        return value ? 'Yes' : 'No';
      default:
        return String(value);
    }
  }

  /**
   * Generate Excel with multiple sheets
   */
  async generateMultiSheetExcel(
    title: string,
    sheets: { name: string; config: ExportConfig }[],
  ): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();

    for (const sheet of sheets) {
      const worksheet = workbook.addWorksheet(sheet.name);
      worksheet.properties.defaultRowHeight = 20;

      // Add sheet-specific content (similar to single sheet generation)
      // Add headers
      const headerRow = worksheet.addRow(
        sheet.config.columns.map((col) => col.header),
      );
      headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
      headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF5B9BD5' },
      };

      // Add data
      sheet.config.data.forEach((row) => {
        const rowData = sheet.config.columns.map((col) =>
          this.getNestedValue(row, col.field),
        );
        worksheet.addRow(rowData);
      });

      // Set column widths
      sheet.config.columns.forEach((col, index) => {
        worksheet.getColumn(index + 1).width = col.width || 15;
      });
    }

    // Generate buffer - ExcelJS returns ArrayBuffer, convert to Buffer
    const arrayBuffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(arrayBuffer);
  }
}
