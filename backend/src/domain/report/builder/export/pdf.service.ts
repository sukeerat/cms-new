import { Injectable } from '@nestjs/common';
import PDFDocument from 'pdfkit';
import { ExportConfig } from '../interfaces/report.interface';

@Injectable()
export class PdfService {
  /**
   * Generate PDF file from data
   */
  async generatePdf(config: ExportConfig): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({
        size: 'A4',
        layout: 'landscape',
        margin: 50,
      });

      const buffers: Buffer[] = [];

      doc.on('data', (chunk) => buffers.push(chunk));
      doc.on('end', () => {
        const buffer = Buffer.concat(buffers);
        console.log(`[PdfService] Generated PDF buffer: ${buffer.length} bytes`);
        resolve(buffer);
      });
      doc.on('error', reject);

      // Add header
      this.addHeader(doc, config);

      // Add metadata
      if (config.metadata) {
        this.addMetadata(doc, config.metadata);
      }

      // Add table
      this.addTable(doc, config);

      // Add footer
      this.addFooter(doc);

      // Finalize PDF
      doc.end();
    });
  }

  /**
   * Add header to PDF
   */
  private addHeader(doc: typeof PDFDocument, config: ExportConfig): void {
    doc
      .fontSize(20)
      .font('Helvetica-Bold')
      .text(config.title, { align: 'center' });

    doc.moveDown();
    doc
      .strokeColor('#5B9BD5')
      .lineWidth(2)
      .moveTo(50, doc.y)
      .lineTo(doc.page.width - 50, doc.y)
      .stroke();

    doc.moveDown();
  }

  /**
   * Add metadata to PDF
   */
  private addMetadata(doc: typeof PDFDocument, metadata: any): void {
    doc.fontSize(10).font('Helvetica');

    if (metadata.generatedAt) {
      doc.text(`Generated: ${metadata.generatedAt.toLocaleString()}`, {
        align: 'left',
      });
    }

    if (metadata.generatedBy) {
      doc.text(`Generated By: ${metadata.generatedBy}`, { align: 'left' });
    }

    doc.moveDown();
  }

  /**
   * Add table to PDF
   */
  private addTable(doc: typeof PDFDocument, config: ExportConfig): void {
    const tableTop = doc.y;
    const itemHeight = 25;
    const pageHeight = doc.page.height - 100;

    // Calculate column widths
    const availableWidth = doc.page.width - 100;
    const columnWidth = availableWidth / config.columns.length;

    // Draw table header
    this.drawTableHeader(doc, config, tableTop, columnWidth);

    let currentY = tableTop + itemHeight;
    let rowIndex = 0;

    // Draw table rows
    for (const row of config.data) {
      // Check if we need a new page
      if (currentY > pageHeight) {
        doc.addPage();
        currentY = 50;
        this.drawTableHeader(doc, config, currentY, columnWidth);
        currentY += itemHeight;
      }

      this.drawTableRow(doc, config, row, currentY, columnWidth, rowIndex);
      currentY += itemHeight;
      rowIndex++;
    }
  }

  /**
   * Draw table header
   */
  private drawTableHeader(
    doc: typeof PDFDocument,
    config: ExportConfig,
    y: number,
    columnWidth: number,
  ): void {
    doc
      .rect(50, y, doc.page.width - 100, 25)
      .fillAndStroke('#5B9BD5', '#000000');

    doc.fontSize(10).font('Helvetica-Bold').fillColor('#FFFFFF');

    config.columns.forEach((col, index) => {
      const x = 50 + index * columnWidth;
      doc.text(col.header, x + 5, y + 8, {
        width: columnWidth - 10,
        align: 'left',
      });
    });

    doc.fillColor('#000000');
  }

  /**
   * Draw table row
   */
  private drawTableRow(
    doc: typeof PDFDocument,
    config: ExportConfig,
    row: any,
    y: number,
    columnWidth: number,
    rowIndex: number,
  ): void {
    // Alternate row colors
    const fillColor = rowIndex % 2 === 0 ? '#F5F5F5' : '#FFFFFF';
    doc
      .rect(50, y, doc.page.width - 100, 25)
      .fillAndStroke(fillColor, '#CCCCCC');

    doc.fontSize(9).font('Helvetica').fillColor('#000000');

    config.columns.forEach((col, index) => {
      const x = 50 + index * columnWidth;
      const value = this.getNestedValue(row, col.field);
      const formattedValue = this.formatValue(value, col.type, col.format);

      doc.text(formattedValue, x + 5, y + 8, {
        width: columnWidth - 10,
        align: col.type === 'number' ? 'right' : 'left',
        ellipsis: true,
      });
    });
  }

  /**
   * Add footer to PDF
   */
  private addFooter(doc: typeof PDFDocument): void {
    const pages = doc.bufferedPageRange();

    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i);

      doc
        .fontSize(8)
        .font('Helvetica')
        .text(
          `Page ${i + 1} of ${pages.count}`,
          50,
          doc.page.height - 50,
          {
            align: 'center',
          },
        );
    }
  }

  /**
   * Get nested value from object using dot notation
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, prop) => current?.[prop], obj);
  }

  /**
   * Format value based on type and format
   */
  private formatValue(value: any, type: string, format?: string): string {
    if (value === null || value === undefined) {
      return '';
    }

    switch (type) {
      case 'date':
        const date = value instanceof Date ? value : new Date(value);
        return date.toLocaleDateString();
      case 'number':
        const num = typeof value === 'number' ? value : parseFloat(value) || 0;
        return format ? num.toFixed(parseInt(format)) : num.toString();
      case 'boolean':
        return value ? 'Yes' : 'No';
      default:
        return String(value);
    }
  }
}
