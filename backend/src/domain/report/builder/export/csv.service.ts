import { Injectable } from '@nestjs/common';
import { ExportConfig } from '../interfaces/report.interface';

@Injectable()
export class CsvService {
  /**
   * Generate CSV file from data
   */
  async generateCsv(config: ExportConfig): Promise<Buffer> {
    const lines: string[] = [];

    // Add title as a comment
    lines.push(`# ${config.title}`);

    // Add metadata as comments
    if (config.metadata) {
      if (config.metadata.generatedAt) {
        lines.push(
          `# Generated: ${config.metadata.generatedAt.toLocaleString()}`,
        );
      }
      if (config.metadata.generatedBy) {
        lines.push(`# Generated By: ${config.metadata.generatedBy}`);
      }
      lines.push(''); // Empty line
    }

    // Add headers
    const headers = config.columns.map((col) => this.escapeCsvValue(col.header));
    lines.push(headers.join(','));

    // Add data rows
    for (const row of config.data) {
      const rowData = config.columns.map((col) => {
        const value = this.getNestedValue(row, col.field);
        const formattedValue = this.formatValue(value, col.type, col.format);
        return this.escapeCsvValue(formattedValue);
      });
      lines.push(rowData.join(','));
    }

    // Convert to buffer
    const buffer = Buffer.from(lines.join('\n'), 'utf-8');
    console.log(`[CsvService] Generated CSV buffer: ${buffer.length} bytes`);
    return buffer;
  }

  /**
   * Escape CSV value (handle commas, quotes, newlines)
   */
  private escapeCsvValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }

    const stringValue = String(value);

    // If value contains comma, quote, or newline, wrap in quotes and escape internal quotes
    if (
      stringValue.includes(',') ||
      stringValue.includes('"') ||
      stringValue.includes('\n') ||
      stringValue.includes('\r')
    ) {
      return `"${stringValue.replace(/"/g, '""')}"`;
    }

    return stringValue;
  }

  /**
   * Get nested value from object using dot notation
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, prop) => current?.[prop], obj);
  }

  /**
   * Format value based on type and format
   */
  private formatValue(value: any, type: string, format?: string): string {
    if (value === null || value === undefined) {
      return '';
    }

    switch (type) {
      case 'date':
        const date = value instanceof Date ? value : new Date(value);
        return date.toISOString();
      case 'number':
        const num = typeof value === 'number' ? value : parseFloat(value) || 0;
        return format ? num.toFixed(parseInt(format)) : num.toString();
      case 'boolean':
        return value ? 'true' : 'false';
      default:
        return String(value);
    }
  }

  /**
   * Parse CSV to JSON (utility method)
   */
  parseCsv(csvContent: string): any[] {
    const lines = csvContent.split('\n').filter((line) => line.trim());
    const result: any[] = [];

    // Skip comment lines and get headers
    let headerIndex = 0;
    while (headerIndex < lines.length && lines[headerIndex].startsWith('#')) {
      headerIndex++;
    }

    if (headerIndex >= lines.length) {
      return result;
    }

    const headers = this.parseCsvLine(lines[headerIndex]);

    // Parse data rows
    for (let i = headerIndex + 1; i < lines.length; i++) {
      const values = this.parseCsvLine(lines[i]);
      const row: any = {};

      headers.forEach((header, index) => {
        row[header] = values[index] || '';
      });

      result.push(row);
    }

    return result;
  }

  /**
   * Parse a single CSV line
   */
  private parseCsvLine(line: string): string[] {
    const result: string[] = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = line[i + 1];

      if (char === '"') {
        if (inQuotes && nextChar === '"') {
          // Escaped quote
          current += '"';
          i++; // Skip next quote
        } else {
          // Toggle quote state
          inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        // End of field
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }

    // Add last field
    result.push(current.trim());

    return result;
  }
}
